options:
  spellbookName: "Â§5Spellbook"
  wandName: "Â§5Magic Stick"
  wandLore: "Â§dRight click to quickly swap to shield charm." and "Â§dSneak right click to open spell menu."


  spellRange: 100
  shieldSpellDuration: 3
  damageSpellDamage: 5
  maxMagicXpLevelChangeAtOnce: 10



variables:
  {magic.spell_costs::shield} = 10

  {magic.spell_costs::disarm} = 15
  {magic.spell_costs::repulse} = 20
  {magic.spell_costs::armour_swap} = 20
  {magic.spell_costs::freeze} = 25

  {magic.spell_costs::damage} = 15
  {magic.spell_costs::burn} = 20
  {magic.spell_costs::combust} = 50

  {magic.leveling_constants.base} = 1.02      # magic number that does the exponenting or something idk
  {magic.leveling_constants.const} = 50      # base amount of xp needed for leveling up to level 1



function getSpellUnlocked(p: player, s: string) :: boolean:
  return {magic.spells::%{_p}%.%{_s}%}
function setSpellUnlocked(p: player, s: string, v: boolean):
  set {magic.spells::%{_p}%.%{_s}%} to {_v}
function spellItem(p: player, i: itemtype, s: string) :: itemtype:
  if getSpellUnlocked({_p}, {_s}) is true:
    return {_i}
  else:
    return iron bars


function selectSpell(p: player, s: string):
  if getSpellUnlocked({_p}, {_s}) is not true:
    if level of {_p} >= {magic.spell_costs.%{_s}%}:
      addXpLevels({_p}, 0 - {magic.spell_costs.%{_s}%})
      setSpellUnlocked({_p}, {_s}, true)
      send "Â§a%{magic.spell_costs.%{_s}%}% Â§2XP levels spent to unlock the spell Â§a%{_s}%Â§2." to {_p}
      make {_p} execute command "/spellmenu"
    else:
      send "Â§c%{magic.spell_costs.%{_s}%}% Â§4XP levels are required to unlock this spell!" to {_p}
    stop

  set {_spell_before_swap} to metadata "sel_magic_spell" of {_p}
  if {_spell_before_swap} is "shield":
    quickswapShieldSpell({_p})
  set metadata "sel_magic_spell" of {_p} to {_s}
  send "Â§3Selected spell changed from Â§b%{_spell_before_swap}%Â§3 to Â§b%{_s}%Â§3." to {_p}
  close {_p}'s inventory


function holdingWand(p: player) :: boolean:
  if name of {_p}'s tool is {@wandName}:
    return true
  else:
    return false

function hasSpellbook(p: player) :: boolean:
  if name of {_p}'s offhand tool is {@spellbookName}:
    return true
  else:
    return false



# function for calculating the amount of xp to the next
# level at a certain level based on an exponential function
# https://www.desmos.com/calculator/auubsajefh
function getMagicXpToLevelUp(lvl: number) :: number:
  set {_base} to {magic.leveling_constants.base}
  set {_factor} to {magic.leveling_constants.factor}
  set {_const} to {magic.leveling_constants.const}
  return {_base} ^ {_lvl} * {_const} # returns the xp needed for the level

# function getMagicLevel(xp: number) :: number:
#   set {_base} to {magic.leveling_constants.base}
#   set {_factor} to {magic.leveling_constants.factor}
#   set {_const} to {magic.leveling_constants.const}

#   # i dont understand any of this
#   # https://www.symbolab.com/solver/algebra-calculator/y%3D%5Cleft(l%5E%7Bx%7D%5Cright)%5Ccdot%20a
#   return (ln({_xp} / {_const})) / (ln({_base})) # returns level at specified xp

function addMagicXp(p: player, amt: number):
  set {magic.xp::%{_p}%.points} to 0 if {magic.xp::%{_p}%.points} is not set
  set {magic.xp::%{_p}%.level} to 0 if {magic.xp::%{_p}%.level} is not set

  set {_curr_lvl} to {magic.xp::%{_p}%.level} otherwise 0
  set {_next_lvl_up} to getMagicXpToLevelUp({_curr_lvl})

  add {_amt} to {magic.xp::%{_p}%.points}
  set {_i} to 0
  while {magic.xp::%{_p}%.points} > {_next_lvl_up}: # level up
    add 1 to {_i}
    if {_i} > {@maxMagicXpLevelChangeAtOnce}:
      stop
    subtract {_next_lvl_up} from {magic.xp::%{_p}%.points}
    add 1 to {magic.xp::%{_p}%.level}
    send "Â§5Â§lâ†‘ You are now Â§dLevel %{magic.xp::%{_p}%.level}% Â§5Â§lin magic XP." to {_p}

  set {_i} to 0
  while {magic.xp::%{_p}%.points} < 0: # negative number added
    add 1 to {_i}
    if {_i} > {@maxMagicXpLevelChangeAtOnce}:
      stop
    add getMagicXpToLevelUp({_curr_lvl} - 1) to {magic.xp::%{_p}%.points}
    subtract 1 from {magic.xp::%{_p}%.level}
    send "Â§5Â§lâ†“ You are now Â§dLevel %{magic.xp::%{_p}%.level}% Â§5Â§lin magic XP. Â§7Â§o(A negative number was passed into the addMagicXp() function. Ask an admin if something is very broken.)" to {_p}




function getMana(p: player) :: number:
  return {magic.mana::%{_p}%}
function setMana(p: player, amt: number):
  set {magic.mana::%{_p}%} to {_amt}
function addMana(p: player, amt: number):
  add {_amt} to {magic.mana::%{_p}%}
function notEnoughMana(p: player, amt: number):
  send action bar "Â§d%{_amt}%Â§5 mana is required!" to {_p}

function getMaxMana(p: player) :: number:
  return floor(log({magic.xp::%{_p}%.level} + 1) * 76 + 20)
function capMana(p: player):
  if getMana({_p}) > getMaxMana({_p}):
    setMana({_p}, getMaxMana({_p}))



function getSpellbookDamageMultiplier() :: number:
  return 1.25
function applyDamageMultiplier(p: player, dmg: number) :: number:
  set {_mult} to (getMana({_p}) / getMaxMana({_p}) / 2)
  if hasSpellbook({_p}):
    set {_mult} to {_mult} * getSpellbookDamageMultiplier()
  return {_dmg} * {_mult}


function getSpellbookDefenceMultiplier() :: number:
  return 0.5
function applyDefenceMultiplier(p: entity, dmg: number) :: number:
  set {_mult} to 1
  if hasSpellbook({_p}):
    set {_mult} to {_mult} * getSpellbookDefenceMultiplier()
  return {_dmg} * {_mult}


function getSpellbookManaCostMultiplier() :: number:
  return 0.5
function applyManaCostMultiplier(p: player, cost: number) :: number:
  set {_mult} to 1
  if hasSpellbook({_p}):
    set {_mult} to {_mult} * getSpellbookManaCostMultiplier()
  return {_cost} * {_mult}

function getSpellbookManaRegenMultiplier() :: number:
  return 0.75
function applyManaRegenMultiplier(p: player, cost: number) :: number:
  set {_mult} to log({magic.xp::%{_p}%.level} + 2.155) * 3
  if hasSpellbook({_p}):
    set {_mult} to {_mult} * getSpellbookManaRegenMultiplier()
  return {_cost} * {_mult}


function spellParticles(par: string, uuid: string, len: number, amt: number):
  loop {_len} times:
    make console execute command "/execute at %{_uuid}% anchored eyes run particle %{_par}% ^-%loop-number% ^ ^ 0 0 0 1 %{_amt}%"

function quickswapShieldSpell(p: player):
  set {_spell_before_swap} to metadata "sel_magic_spell" of {_p}
  if {_spell_before_swap} is "shield":
    set metadata "sel_magic_spell" of {_p} to metadata "prev_sel_magic_spell" of {_p}
    set metadata "prev_sel_magic_spell" of {_p} to "shield"
  else:
    set metadata "prev_sel_magic_spell" of {_p} to metadata "sel_magic_spell" of {_p}
    set metadata "sel_magic_spell" of {_p} to "shield"


function addXpLevels(p: player, amt: number):
  make console execute command "/xp add %{_p}% %{_amt}% levels"

function shieldSpellRemaining(p: player) :: timespan:
  if metadata "magic_shield" of {_p} is set:
    set {_time} to metadata "magic_shield" of {_p}
    set {_diff} to difference between {_time} and now
    set {_remaining} to difference between {_diff} and {@shieldSpellDuration} seconds
    if {_remaining} > 0 seconds:
      return {_remaining}



function castSpell(p: player, s: string):
  set {_mana_req} to applyManaCostMultiplier({_p}, {magic.spell_costs.%{_s}%})
  if getMana({_p}) < {_mana_req}:
    notEnoughMana({_p}, {_mana_req})
    stop

  if {_s} is "shield":
    apply glowing to {_p} for {@shieldSpellDuration} seconds
    set metadata "magic_shield" of {_p} to now
    show 100 totem at {_p}
    addMana({_p}, 0 - {_mana_req})
    stop
  
  if shieldSpellRemaining({_p}) is set:
    delete metadata "magic_shield" of {_p}
    # send "Â§3Your shield charm was broken as you casted another spell while it was active." to {_p}
  shoot snowball from {_p}


  addMana({_p}, 0 - {_mana_req})
  send action bar "Â§5Casted spell Â§d%{_s}%Â§5." to {_p}



on join: # default spells unlocked for all players
  setSpellUnlocked(player, "shield", true)
  setSpellUnlocked(player, "damage", true)

command /unlockspell <player> <string> [<string>]:
  trigger:
    if player is not op:
      send "Â§cInsufficient permission!"
      stop
    set {_v} to true
    set {_v} to false if arg-3 is set
    setSpellUnlocked(arg-1, arg-2, {_v})
    send "ok"

command /setmagiclevel <number> <player=%player%>:
  trigger:
    if player is not op:
      send "Â§cInsufficient permission!"
      stop
    set {magic.xp::%arg-2%.level} to arg-1
    send "ok"

command /setmagicpoints <number> <player=%player%>:
  trigger:
    if player is not op:
      send "Â§cInsufficient permission!"
      stop
    set {magic.xp::%arg-2%.points} to arg-1
    send "ok"

command /mana <number> <player=%player%>:
  trigger:
    if player is not op:
      send "Â§cInsufficient permission!"
      stop
    setMana(arg-2, arg-1)
    
command /spellmenu:
  trigger:
    stop if holdingWand(player) is not true

    open chest with 4 rows named "Spell Menu" to player
    wait 1 tick
    loop 36 times:
      format slot (loop-number - 1) of player with light gray stained glass pane named " " to be unstealable
    loop 9 times:
      format slot (loop-number + 27 - 1) of player with red stained glass pane named "Â§cCancel" to close

    wait 1 tick
    format slot 0 of player with spellItem(player, totem of undying, "shield") named "Â§5Shield Charm" with lore "Â§dCost: %{magic.spell_costs::shield}%" to run [send "Â§dThis spell is not selected from the menu. Right click with your magic stick to toggle the spell." to player]
    format slot 9 of player with spellItem(player, stick, "disarm") named "Â§5Disarming Jinx" with lore "Â§dCost: %{magic.spell_costs::disarm}%" to run [selectSpell(player, "disarm")]
    format slot 10 of player with spellItem(player, piston, "repulse") named "Â§5Repulsing Spell" with lore "Â§dCost: %{magic.spell_costs::repulse}%" to run [selectSpell(player, "repulse")]
    format slot 11 of player with spellItem(player, iron chestplate, "armour_swap") named "Â§5Armour Swap Jinx" with lore "Â§dCost: %{magic.spell_costs::armour_swap}%" to run [selectSpell(player, "armour_swap")]
    format slot 12 of player with spellItem(player, ice, "freeze") named "Â§5Freezing Jinx" with lore "Â§dCost: %{magic.spell_costs::freeze}%" to run [selectSpell(player, "freeze")]
    format slot 18 of player with spellItem(player, bread, "damage") named "Â§5Pain" with lore "Â§dBasic damage spell dealing {@damageSpellDamage} damage.", "Â§dCost: %{magic.spell_costs.damage}%" to run [selectSpell(player, "damage")]
    format slot 19 of player with spellItem(player, fire charge, "burn") named "Â§5Inflammation" with lore "Â§dCost: %{magic.spell_costs::burn}%" to run [selectSpell(player, "burn")]
    format slot 20 of player with spellItem(player, tnt, "combust") named "Â§5Combustion" with lore "Â§dCost: %{magic.spell_costs::combust}%" to run [selectSpell(player, "combust")]



command /getmagicitem <text>:
  trigger:
    if player is not op:
      send "Â§cInsufficient permission!"
      stop
    if arg-1 is "spellbook":
      give player shiny book named {@spellbookName} with lore "Â§7While in offhand:", "Â§ax%getSpellbookManaCostMultiplier()% Mana Cost",  "Â§ax%getSpellbookDamageMultiplier()% Attack", "Â§cx%getSpellbookManaRegenMultiplier()% Mana Regen Rate", "Â§cx%getSpellbookDefenceMultiplier()% Magic Defence"
    if arg-1 is "wand":
      give player shiny stick named {@wandName} with lore {@wandLore}


on right click:
  player's gamemode is not spectator
  if holdingWand(player):
    cancel event
    if player is not sneaking:
      quickswapShieldSpell(player)
      set {_spell} to metadata "sel_magic_spell" of player
      set {_prev_spell} to metadata "prev_sel_magic_spell" of player
      send "Â§3Quickswapped spells from Â§b%{_prev_spell}%Â§3 to Â§b%{_spell}%Â§3."
    else:
      make player execute command "/spellmenu"

on left click:
  player's gamemode is not spectator
  if holdingWand(player):
    if metadata "sel_magic_spell" of player is not set:
      send "Â§cSelect a spell!"
      stop
    cancel event
    set metadata "using_magic_spell" of player to metadata "sel_magic_spell" of player
    set {_spell} to metadata "using_magic_spell" of player
    castSpell(player, {_spell})
    delete metadata "using_magic_spell" of player

on shoot:
  shooter is player
  metadata "using_magic_spell" of shooter is set
  set {_spell} to metadata "using_magic_spell" of shooter
  set metadata "spell_projectile" of projectile to {_spell}
  set metadata "spell_projectile_spawn_loc" of projectile to location of shooter



on projectile hit:
  metadata "spell_projectile" of projectile is set
  set {_spell} to metadata "spell_projectile" of shooter

  if block is set:
    show 1 flash at projectile




on item spawn: # disarming jinx
  metadata "magically_disarmed" of event-entity is set
  set {_disarmer} to metadata "magically_disarmed" of event-entity
  set {_item} to event-item
  set {_vector} to vector between {_item} and {_disarmer}
  push {_item} {_vector} with force 5

on damage:
  projectile is set # because damage cause is projectile doesnt work
  metadata "spell_projectile" of projectile is set
  cancel event
  set {_spell} to metadata "spell_projectile" of projectile


  if metadata "magic_shield" of victim is set:
    set {_shield_timestamp} to metadata "magic_shield" of victim
    if difference between now and {_shield_timestamp} < {@shieldSpellDuration} seconds:
      addMana(victim, -5)
      stop

  make attacker damage victim by 0.0001

  if {_spell} is "disarm":
    chance of applyDamageMultiplier(attacker, 1/3)
    drop victim's tool
    set victim's tool to air
    set metadata "magically_disarmed" of victim to attacker
  if {_spell} is "repulse":
    set {_force} to applyDamageMultiplier(attacker, 3)
    push victim (direction from attacker to victim) at force {_force}
  if {_spell} is "armour_swap":
    set {_h} to helmet of victim
    if chance of 1/3:
      set helmet of victim to chestplate of victim
      set chestplate of victim to {_h}
    else if chance of 1/2:
      set helmet of victim to leggings of victim
      set leggings of victim to {_h}
    else:
      set helmet of victim to boots of victim
      set boots of victim to {_h}
  if {_spell} is "freeze":
    # add attacker to {_p::*}
    # add victim to {_p::*}
    apply slowness 3 to victim for 2 seconds
    loop blocks in radius 3 around victim:
      chance of 80%
      loop-block is air
      make all players see loop-block as ice
  if {_spell} is "damage":
    set {_dmg} to applyDamageMultiplier(attacker, {@damageSpellDamage})
    set {_dmg_after_def} to applyDefenceMultiplier(victim, {_dmg})
    make attacker damage victim by {_dmg_after_def}
  if {_spell} is "burn":
    ignite victim for 20 seconds
  if {_spell} is "combust":
    set {_force} to applyDefenceMultiplier(victim, 2)
    create safe explosion of force {_force} at victim

  set {_add_xp} to {magic.spell_costs.%{_spell}%} / 10
  addMagicXp(attacker, {_add_xp})
  play sound "block.note_block.pling" to attacker
  send action bar "Â§5Struck Â§d%victim%Â§5 with Â§d%{_spell}% Â§5spell! (Â§d+%{_add_xp}% Â§dMagic XPÂ§5)" to attacker
  send action bar "Â§4Struck by Â§c%{_spell}% Â§4spell cast by Â§c%attacker%Â§4!" to victim

every second:
  loop all players:
    set {_add_mana} to 1
    addMana(loop-player, applyManaRegenMultiplier(loop-player, {_add_mana}))
    capMana(loop-player)

every 2 seconds:
  loop all players:

    if holdingWand(loop-player):
      set {_time} to metadata "magic_shield" of loop-player
      set {_diff} to difference between {_time} and now
      if {_diff} < {@shieldSpellDuration} seconds:
        send action bar "Â§3Shielded from magic damage for Â§b%shieldSpellRemaining(loop-player)%Â§3." to loop-player
      else:
        set {_spell} to metadata "sel_magic_spell" of loop-player
        send action bar "Â§6Â§lâ­ Â§e%{_spell}% [%applyManaCostMultiplier(loop-player, {magic.spell_costs::%{_spell}%})%Â§e] Â§8| Â§5Â§lðŸ”¥ Mana: Â§d%getMana(loop-player)%Â§5/Â§d%getMaxMana(loop-player)% Â§7| Â§5Â§lCost: Â§dx%applyManaCostMultiplier(loop-player, 1)% Â§7| Â§5Â§lRegen: Â§dx%applyManaRegenMultiplier(loop-player, 1)% Â§8| Â§4Â§lâš” Â§cx%applyDamageMultiplier(loop-player, 1)% Â§7| Â§3Â§lðŸ›¡ Â§bx%applyDefenceMultiplier(loop-player, 1)%" to loop-player

every 3 ticks:
  loop all entities:
    loop-entity is snowball
    metadata "spell_projectile" of loop-entity is set
    set {_spell} to metadata "spell_projectile" of loop-entity
    set {_spawn_loc} to  metadata "spell_projectile_spawn_loc" of loop-entity
    if distance between {_spawn_loc} and location of loop-entity > {@spellRange}:
      kill loop-entity
      continue
    
    if {_spell} is "damage":
      spellParticles("crit", uuid of loop-entity, 15, 5)
    else if {_spell} is "burn" or "combust":
      spellParticles("flame", uuid of loop-entity, 15, 5)
    else:
      spellParticles("end_rod", uuid of loop-entity, 15, 5)